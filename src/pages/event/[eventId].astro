---
export const prerender = false
import { getDb, siteSchema } from "@db/index";
import { eq, isNull, and } from "drizzle-orm";
import EventWaitRoom from "@components/EventWaitRoom.astro";
import EventLiveRoom from "@components/EventLiveRoom.astro";
import EventClosedRoom from "@components/EventClosedRoom.astro";
import { generateId } from "@utils/MainUtils";

const db = getDb()
const { eventId } = Astro.params;

let event = null;

if (!eventId) {
	return Astro.redirect("/");
}

const GetAllQuizes = await db.query.question.findMany({
	where:(and(
		eq(siteSchema.question.eventId, eventId),
		isNull(siteSchema.question.questionDeletedAt)
	)),
  with: {
    options: true
  }
});

// console.log(JSON.stringify(GetAllQuizes))

try {
	event = db
		.select()
		.from(siteSchema.event)
		.where(and(
			eq(siteSchema.event.eventId, eventId),
			isNull(siteSchema.event.eventDeletedAt)
		))
		.get();
	
	if (!event) {
		return Astro.redirect("/");
	}
} catch (error) {
	console.error("Database error:", error);
	return Astro.redirect("/");
}

type EventState = "WAITING" | "LIVE" | "ENDED";

let eventState: EventState;

const now = new Date();
const scheduledStart = new Date(event.eventScheduledStartAt!);
const scheduledEnd = new Date(event.eventScheduledEndAt!);

if (now < scheduledStart) {
	eventState = "WAITING";
} else if (now >= scheduledStart && now < scheduledEnd) {
	eventState = "LIVE";
} else {
	eventState = "ENDED";
}



if (Astro.request.method === "POST") {
	const formData = await Astro.request.formData();
	let participantId: string | null = null;
	const answers = new Map<string, string[]>();
	
	for (const [key, value] of formData.entries()) {
		if (key === "participantId") {
			participantId = String(value);
			continue;
		}
		if (!answers.has(key)) {
			answers.set(key, []);
		}
		answers.get(key)!.push(String(value));
	}
	
	if (participantId && answers.size > 0) {
		try {
			const submissionId = generateId()
			const now = new Date().toISOString();
			
			await db.insert(siteSchema.submission).values({
				submissionId: submissionId,
				submissionCreatedAt: now,
				submissionUpdatedAt: null,
				submissionDeletedAt: null,
				eventId: eventId,
				participantId: participantId,
			});
			
			const responseRecords = [];
			for (const [questionId, optionIds] of answers.entries()) {
				for (const optionId of optionIds) {
					responseRecords.push({
						responseId: generateId(),
						responseCreatedAt: now,
						responseUpdatedAt: null,
						responseDeletedAt: null,
						questionId: questionId,
						optionId: optionId,
						submissionId: submissionId,
					});
				}
			}
			

			if (responseRecords.length > 0) {
				await db.insert(siteSchema.response).values(responseRecords);
			}
			
			return Astro.redirect(`/event/${eventId}?submitted=1`);
			
		} catch (error) {
			console.error("Error saving submission:", error);
		}
	}
}



const cookie = Astro.cookies.get("registeredForEvent");

let participationId: string | null = null;

if (cookie) {
  const data = JSON.parse(cookie.value);
  participationId = data.participantId;
}




---

{eventState === "WAITING" && (
	<EventWaitRoom
		Id={event.eventId}
		Title={event.eventTitle}
		Description={event.eventDescription}
		StartAt={event.eventScheduledStartAt}
		EndAt={event.eventScheduledEndAt}
	/>
)}


{eventState === "LIVE" && (
	<EventLiveRoom
		id={event.eventId}
		participant={participationId!}
		title={event.eventTitle}
		description={event.eventDescription}
		startAt={event.eventScheduledStartAt}
		endAt={event.eventScheduledEndAt}
		Quie={GetAllQuizes}
	/>
)}


{eventState === "ENDED" && (
	<EventClosedRoom
		Title={event.eventTitle}
		Description={event.eventDescription}
		StartAt={event.eventScheduledStartAt}
		EndAt={event.eventScheduledEndAt}
	/>
)}
