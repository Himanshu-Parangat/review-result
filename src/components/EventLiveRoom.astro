---
export const prerender = false
import TwoColumnLayout from "@layouts/TwoColumnLayout.astro"
import Timestamp from "@components/Timestamp.astro"
import { siteSchema } from "@db/index";
import type { InferSelectModel } from "drizzle-orm";

type Question = InferSelectModel<typeof siteSchema.question>;
type Option = InferSelectModel<typeof siteSchema.option>;

type QuestionWithOptions = Question & {
	options: Option[];
};

interface Props {
	id: string | null
	participant: string
	title: string | null
	description: string | null
	startAt: string | null
	endAt: string | null
	Quie:  QuestionWithOptions[];
}

const { id, title, description, startAt, endAt, Quie, participant} = Astro.props as Props


---
<TwoColumnLayout title="event">

	<div slot="max-slot" class="h-full">
		<div class="border-2 border-primary bg-secondary h-full rounded-xl p-4  flex flex-col items-center overflow-y-auto">
			<h1 class="text-xl font-bold items-center">{title}</h1>
			<div class=" border-b-2 border-primary w-full mt-2"></div>

				<form method="post" id="submitforum"  class="flex flex-col w-full mt-4 px-8 py-4 h-full lg:overflow-y-auto">
				<input type="hidden" name="participantId" value={participant}>
				<input type="hidden" name="action" value="create">

				<div id="quiz-container" data-quiz-id={participant}>
				{Quie.map((question,index) =>
				<div id={"question-" + question.questionId} class="quiz-question mb-8 border-2 border-primary bg-tertiary rounded-lg p-4 scroll-mt-24 quiz-jump-target hover:scale-[1.02]">
						<div class=" flex flex-row justify-start gap-4">
							<div class="question-number shrink-0 text-primary text-lg bg-accent flex justify-center items-center rounded-lg w-10 h-10">
								{index + 1}
							</div>

							<details class="group w-full" open="true">
								<summary class="list-none cursor-pointer flex justify-between  w-full">
									<h1 class="text-2xl">{question.questionTitle}</h1>

									<svg xmlns="http://www.w3.org/2000/svg"
										class="shrink-0 ml-16 w-8 h-8 text-primary transition-transform duration-200 group-open:rotate-180 mr-4 mt-0"
										fill="none" viewBox="0 0 24 24" stroke="currentColor">
										<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
											d="M19 9l-7 7-7-7" />
									</svg>
								</summary>
								<h2 class="text-xl text-secondary mt-2">{question.questionDescription}</h2>
							</details>

						</div>


						<div class="ml-9 mr-4 mt-6 space-y-4 pl-3 py-3 ">
							{question.options.map((option,i) => {
								const letter = String.fromCharCode(65 + i)
								return (
									<label class="option-item flex text-2xl items-start p-3 pl-4 border-2 border-primary rounded-lg cursor-pointer hover-overlay text-secondary">
										<input 
											type={question.questionType}
											name={question.questionId}
											value={option.optionId}
											class=" mt-[0.40em] w-4 h-4 text-accent text-2xl scale-150 mr-4"
										/>
										<span class="text-xl leading-relaxed flex-1">
											{letter}. {option.optionTitle}
										</span>
									</label>
								)
							})}

						</div>
					</div>
				)}
				</div>
				</form>

		</div>

		<script>
			function seededRandom(seed: string) {
				let h = 0;
				for (let i = 0; i < seed.length; i++) {
					h = Math.imul(31, h) + seed.charCodeAt(i) | 0;
				}
				return function() {
					h = Math.imul(h ^ h >>> 16, 0x85ebca6b);
					h = Math.imul(h ^ h >>> 13, 0xc2b2ae35);
					return ((h ^ h >>> 16) >>> 0) / 4294967296;
				};
			}

			function shuffle<T>(array: T[], seed: string): T[] {
				const rng = seededRandom(seed);
				const arr = [...array];
				for (let i = arr.length - 1; i > 0; i--) {
					const j = Math.floor(rng() * (i + 1));
					[arr[i], arr[j]] = [arr[j], arr[i]];
				}
				return arr;
			}

			document.addEventListener('DOMContentLoaded', () => {
				const quizId = document.getElementById('quiz-container')?.dataset.quizId;
				if (!quizId) return;

				const questions = Array.from(document.querySelectorAll('.quiz-question'));
				const shuffled = shuffle(questions, quizId);
				const container = questions[0]?.parentElement;
				if (container) {
					shuffled.forEach((q, index) => {
						const numEl = q.querySelector('.question-number');
						if (numEl) numEl.textContent = String(index + 1);
						container.appendChild(q);
					});
				}

				questions.forEach(q => {
					const qId = q.id;
					const options = Array.from(q.querySelectorAll('.option-item'));
					const shuffledOpts = shuffle(options, `${quizId}-${qId}`);
					const optContainer = options[0]?.parentElement;
					if (optContainer) {
						shuffledOpts.forEach((opt, i) => {
							const letter = String.fromCharCode(65 + i);
							opt.querySelector('.option-letter')!.textContent = `${letter}.`;
							optContainer.appendChild(opt);
						});
					}
				});
			});
		</script>
	</div>


	<div slot="min-slot" class="h-full">
		<div class="border-2 border-primary bg-secondary h-full rounded-xl p-4 flex flex-col items-center">
			<h1 class="text-xl font-bold items-center">Quiz Tracker</h1>
			<div class="border-b-2 border-primary w-full mt-2"></div>

			<div class="flex flex-col w-full h-full pt-2 px-4">


				<div class="w-full flex flex-row justify-between">
					<h3 class="text-lg font-semibold mt-2">Time Remaining</h3>

					<div class="mt-2 text-lg text-secondary">
						<Timestamp startTime={startAt!} endTime={endAt!} eventName="Event"/>
					</div>

				</div>



				<div class="progress-container relative mt-2 h-5 w-full rounded-xl border-2 border-primary ">
					<div
						class="absolute hidden -top-11 left-0
									 rounded bg-tertiary px-2 py-1 text-primary border-2 border-primary text-base whitespace-nowrap pointer-events-none z-50
									 after:content-[''] after:absolute after:top-full after:left-1/2 after:-translate-x-1/2
									 after:border-8 after:border-transparent after:border-t-primary"
						id="tooltip">
					</div>
					
					<!-- Time progress (bottom layer) -->
					<div class="absolute inset-0 w-full h-full bar-time rounded-xl pointer-events-none"
							 data-value="20"
							 data-start={startAt}
							 data-end={endAt}
							 data-text="Time Remaining">
						<div class="fill h-full bg-tertiary border-2 border-primary hover-overlay rounded-xl transition-all duration-300 pointer-events-auto" style="width: 70%"></div>
					</div>
					
					<!-- Questions progress (top layer) -->
					<div class="absolute inset-0 w-full h-full bar-questions rounded-xl pointer-events-none"
							 data-value="30"
							 data-text="Questions Attempted">
						<div class="fill h-full bg-accent border-2 border-primary rounded-xl transition-all duration-300 pointer-events-auto" style="width: 30%"></div>
					</div>
				</div>


				<div>

					<div class="w-full flex flex-row justify-between">
						<h3 class="text-lg font-semibold mt-2">Questions</h3>
						<span id="question-counter" class="text-lg text-secondary mt-2">0/0</span>
					</div>

					<div class="border-2 border-primary rounded-lg p-4 mt-2  grid grid-cols-[repeat(auto-fill,minmax(2.5rem,1fr))]    gap-2">

						{Quie.map((question,index) => 
						<a href={"#question-"+question.questionId}>
								<div 
									class="shrink-0 text-primary text-lg bg-secondary hover-overlay flex justify-center items-center rounded-lg w-10 h-10 border border-primary question-chip"
									data-question-id={question.questionId}>
									{index +1 }
								</div>
							</a>
						)}

					</div>
				</div>


				<div class="flex-1"> </div>

				<div class="flex flex-col w-full mb-2 items-center">
					<button id="doSubmit" type="submit" form="submitforum" class="flex flex-row items-center gap-3 bg-accent text-lg rounded-lg border-2 border-primary px-8 py-2">

						<span>Finish & Submit</span>
					<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="M4.5 16.5c-1.5 1.26-2 5-2 5s3.74-.5 5-2c.71-.84.7-2.13-.09-2.91a2.18 2.18 0 0 0-2.91-.09z"/>
						<path d="m12 15-3-3a22 22 0 0 1 2-3.95A12.88 12.88 0 0 1 22 2c0 2.72-.78 7.5-6 11a22.35 22.35 0 0 1-4 2z"/>
						<path d="M9 12H4s.55-3.03 2-4c1.62-1.08 5 0 5 0"/>
						<path d="M12 15v5s3.03-.55 4-2c1.08-1.62 0-5 0-5"/>
					</svg>
					</button>


				</div>
			</div>
		</div>

			<script is:inline>
				(function () {
					function formatTimeParts(diff) {
						const absDiff = Math.max(0, Math.abs(diff));

						const days = Math.floor(absDiff / (1000 * 60 * 60 * 24));
						const hours = Math.floor((absDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
						const minutes = Math.floor((absDiff % (1000 * 60 * 60)) / (1000 * 60));
						const seconds = Math.floor((absDiff % (1000 * 60)) / 1000);

						if (days > 0) return `${days}d ${hours}h`;
						if (hours > 0) return `${hours}h ${minutes}m`;
						if (minutes > 0) return `${minutes}m ${seconds}s`;
						return `${seconds}s`;
					}

					function updateTimestamp(element) {
						const startDate = new Date(element.dataset.start).getTime();
						const endDate = new Date(element.dataset.end).getTime();
						const now = Date.now();

						const diffToStart = startDate - now;
						const diffToEnd = endDate - now;

						if (diffToStart > 1000) {
							element.textContent = `Starts in ${formatTimeParts(diffToStart)}`;
						} else if (diffToStart >= 0) {
							element.textContent = `Starts in 0s`;
						} else if (diffToEnd > 1000) {
							element.textContent = `Ongoing (${formatTimeParts(diffToEnd)} left)`;
						} else if (diffToEnd >= 0) {
							element.textContent = `Ending in 0s`;
						} else {
							element.textContent = `Ended ${formatTimeParts(diffToEnd)} ago`;
						}
					}

					function updateTimeProgress() {
						const timeBar = document.querySelector('.bar-time');
						if (!timeBar) return;

						const fill = timeBar.querySelector('.fill');
						if (!fill) return;

						const start = new Date(timeBar.dataset.start).getTime();
						const end = new Date(timeBar.dataset.end).getTime();
						const now = Date.now();

						if (!start || !end || end <= start) return;

						const total = end - start;
						const elapsed = now - start;

						let percent = (elapsed / total) * 100;
						percent = Math.min(100, Math.max(0, percent));

						fill.style.width = `${percent}%`;
						timeBar.dataset.value = percent.toFixed(1);
					}

					function initTimestamps() {
						const timestamps = document.querySelectorAll('.countdown-timestamp');
						if (!timestamps.length) return;

						const tick = () => {
							timestamps.forEach(updateTimestamp);
							updateTimeProgress();
						};

						tick();
						setInterval(tick, 1000);
					}

					if (document.readyState === 'loading') {
						document.addEventListener('DOMContentLoaded', initTimestamps);
					} else {
						initTimestamps();
					}

					document.addEventListener('astro:page-load', initTimestamps);
				})();
			</script>


			<script is:inline>
				const tooltip = document.getElementById('tooltip');
				const timeBar = document.querySelector('.bar-time');
				const questionsBar = document.querySelector('.bar-questions');
				
				if (!tooltip || !timeBar || !questionsBar) {
					console.error('Required elements not found');
				} else {
					function showTooltip(bar, tooltip, event ) {
						const rect = bar.getBoundingClientRect();
						const parent = bar.closest('.progress-container');
						if (!parent) return;
						
						const containerRect = parent.getBoundingClientRect();
						const mouseX = event.clientX - rect.left;
						const barWidth = rect.width;
						
						const percentage = parseFloat(bar.dataset.value || '0');
						const filledWidth = (barWidth * percentage) / 100;
						
						if (mouseX <= filledWidth) {
							tooltip.textContent = bar.dataset.text ?? '';
							tooltip.classList.remove('hidden');
							
							const relativeX = event.clientX - containerRect.left;
							tooltip.style.left = `${relativeX}px`;
							tooltip.style.transform = 'translateX(-50%)';
						} else {
							tooltip.classList.add('hidden');
						}
					}
					
					const timeFill = timeBar.querySelector('.fill');
					const questionsFill = questionsBar.querySelector('.fill');

					if (timeFill instanceof HTMLElement && questionsFill instanceof HTMLElement) {
						timeFill.addEventListener('mousemove', (e) => {
							showTooltip(timeBar, tooltip, e);
						});

						timeFill.addEventListener('mouseleave', () => {
							tooltip.classList.add('hidden');
						});

						questionsFill.addEventListener('mousemove', (e) => {
							showTooltip(questionsBar, tooltip, e);
						});

						questionsFill.addEventListener('mouseleave', () => {
							tooltip.classList.add('hidden');
						});
					}
				}
			</script>



		<script is:inline>
			(function() {
				const questionStates = {};
				const STORAGE_KEY = 'quiz_answers_';
				
				function loadSavedAnswers() {
					try {
						const saved = localStorage.getItem(STORAGE_KEY);
						if (saved) {
							return JSON.parse(saved);
						}
					} catch (e) {
						console.error('Error loading saved answers:', e);
					}
					return {};
				}
				
				// Save answers to localStorage
				function saveAnswers(questionId, selectedValues) {
					try {
						const saved = loadSavedAnswers();
						if (selectedValues && selectedValues.length > 0) {
							saved[questionId] = selectedValues;
						} else {
							delete saved[questionId];
						}
						localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));
					} catch (e) {
						console.error('Error saving answers:', e);
					}
				}
				
				function restoreSavedAnswers() {
					const saved = loadSavedAnswers();
					
					Object.keys(saved).forEach(questionId => {
						const values = saved[questionId];
						values.forEach(value => {
							const input = document.querySelector(`input[name="${questionId}"][value="${value}"]`);
							if (input) {
								input.checked = true;
								questionStates[questionId].answered = true;
							}
						});
					});
				}
				
				function updateChipColor(questionId) {
					const chip = document.querySelector(`.question-chip[data-question-id="${questionId}"]`);
					if (!chip) return;
					
					chip.classList.remove('bg-accent', 'bg-tertiary', 'bg-secondary');
					
					const state = questionStates[questionId];
					if (state?.answered) {
						chip.classList.add('bg-accent');
					} else if (state?.visited) {
						chip.classList.add('bg-tertiary');
					} else {
						chip.classList.add('bg-secondary');
					}
				}
				
				function updateQuestionProgress() {
					const answeredCount = Object.values(questionStates).filter(s => s?.answered).length;
					const totalQuestions = Object.keys(questionStates).length -1 ;

					const counterElement = document.getElementById('question-counter');
					if (counterElement) {
						counterElement.textContent = `Attempted ( ${answeredCount}/${totalQuestions} )`;
					}
					
					if (totalQuestions > 0) {
						const percentage = (answeredCount / totalQuestions) * 100;
						const questionsBar = document.querySelector('.bar-questions');
						const fill = questionsBar?.querySelector('.fill');
						
						if (fill && questionsBar) {
							fill.style.width = `${percentage}%`;
							questionsBar.dataset.value = percentage.toFixed(1);
							
							questionsBar.dataset.text = `Questions Attempted: ${answeredCount}/${totalQuestions}`;
						}
					}
				}
				
				function initQuizFunctionality() {
					document.querySelectorAll('[id^="question-"]').forEach(questionDiv => {
						const questionId = questionDiv.id.replace('question-', '');
						if (!questionStates[questionId]) {
							questionStates[questionId] = { visited: false, answered: false };
						}
					});
					
					restoreSavedAnswers();
					
					const observer = new IntersectionObserver((entries) => {
						entries.forEach(entry => {
							if (entry.isIntersecting) {
								const questionId = entry.target.id.replace('question-', '');
								if (!questionStates[questionId].visited) {
									questionStates[questionId].visited = true;
									updateChipColor(questionId);
								}
							}
						});
					}, { threshold: 0.5 });
					
					document.querySelectorAll('[id^="question-"]').forEach(el => {
						observer.observe(el);
					});
					
					document.querySelectorAll('input[type="radio"]').forEach(radio => {
						let lastChecked = null;
						
						radio.addEventListener('click', function(e) {
							const questionId = this.name;
							
							if (lastChecked === this) {
								this.checked = false;
								lastChecked = null;
								questionStates[questionId].answered = false;
								saveAnswers(questionId, []);
							} else {
								lastChecked = this;
								questionStates[questionId].answered = true;
								saveAnswers(questionId, [this.value]);
							}
							
							updateChipColor(questionId);
							updateQuestionProgress();
						});
					});
					
					document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
						checkbox.addEventListener('change', function() {
							const questionId = this.name;
							const checkedBoxes = document.querySelectorAll(`input[name="${questionId}"]:checked`);
							const anyChecked = checkedBoxes.length > 0;
							
							questionStates[questionId].answered = anyChecked;
							
							const selectedValues = Array.from(checkedBoxes).map(cb => cb.value);
							saveAnswers(questionId, selectedValues);
							
							updateChipColor(questionId);
							updateQuestionProgress();
						});
					});
					
					Object.keys(questionStates).forEach(questionId => {
						updateChipColor(questionId);
					});
					updateQuestionProgress();
				}
				
				if (document.readyState === 'loading') {
					document.addEventListener('DOMContentLoaded', initQuizFunctionality);
				} else {
					initQuizFunctionality();
				}
				
				document.addEventListener('astro:page-load', initQuizFunctionality);
			})();

		</script>

		<script is:inline>
			const submitBtn = document.getElementById('doSubmit');
			const targetForm = document.getElementById('submitforum');

			if (submitBtn && targetForm){
				submitBtn.addEventListener('click', (e) => {
					targetForm.requestSubmit();
					console.log(targetForm)
				});
			}
		</script>

	</div>
</TwoColumnLayout>

